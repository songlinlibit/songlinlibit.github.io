{"meta":{"title":"libit的博客","subtitle":"祝你每天开心","description":"每天进步一丢丢","author":"libit","url":"https://songlinlibit.github.io","root":"/"},"pages":[{"title":"个人简历","date":"1996-10-18T16:00:00.000Z","updated":"2021-06-07T03:01:34.851Z","comments":true,"path":"CV/index.html","permalink":"https://songlinlibit.github.io/CV/index.html","excerpt":"","text":"这是一个简历展示页面包括但不限于个人的专业技能展示，如果仅需了解本人专业知识，为节省您的时间，请移步这里"}],"posts":[{"title":"08/13","slug":"08-13","date":"2021-08-13T09:40:34.000Z","updated":"2021-08-13T09:44:27.367Z","comments":true,"path":"2021/08/13/08-13/","link":"","permalink":"https://songlinlibit.github.io/2021/08/13/08-13/","excerpt":"","text":"647. 回文子串给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 输入：“abc”输出：3解释：三个回文子串: “a”, “b”, “c” 示例 2： 输入：“aaa”输出：6解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa” 提示： 输入的字符串长度不会超过 1000 。 这个题跟昨天做的有一点点像，都是求回文子序列。 所以是可以用昨天动规的思路来求解的。 但是我用了中心扩展法，因为动规的空间复杂度会高一点。 中心扩展法时间复杂度是 $O(N^2)$, 空间复杂度是 $O(1)$ 动态规划时间复杂度是 $O(N^2)$，空间复杂度是 $O(N^2)$ 具体原理就是以每个元素为中心，挨个向两边扩散，比如现在以”bab”中的a为中心扩散，由于’b’ = ‘b’ ，标记为合法的回文子串，继续扩散到达边界结束。 思路就这样，非常简单。想不到有啥需要补充了。 完整代码： 12345678910111213141516171819202122232425class Solution &#123;public: int count(int left, int right, string s)&#123; int len = s.size(); int re = 0; while(left&gt;=0 &amp;&amp; right&lt;len &amp;&amp; s[left] == s[right])&#123; left--; right++; re++; &#125; return re; &#125; int countSubstrings(string s) &#123; int ans = 0; int len = s.size(); for(int i = 0; i&lt;len; i++)&#123; ans++; int left = i -1, right = i+1; ans += count(left,right,s); left = i-1, right = i; ans += count(left,right,s); &#125; return ans; &#125;&#125;; 补充： 后来发现别人更好的方法，因为中心点只能是1个或者2个。 为什么不能是3个，因为3个就是1个往两边扩展了一下呗。 所以代码可以优化一下，主要优化left和right的取值。 1int l=i/2,r=i/2+i%2; 优化后代码如下： 12345678910111213141516171819class Solution &#123;public: int countSubstrings(string s) &#123; int n=s.size(),ans=0; for(int i=0;i&lt;2*n-1;++i)&#123; int l=i/2,r=i/2+i%2; while(l&gt;=0&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r])&#123; l--; r++; ans++; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"08/12","slug":"08-12","date":"2021-08-12T08:52:20.000Z","updated":"2021-08-12T09:31:28.627Z","comments":true,"path":"2021/08/12/08-12/","link":"","permalink":"https://songlinlibit.github.io/2021/08/12/08-12/","excerpt":"","text":"516. 最长回文子序列给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 示例 2： 123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 1 &lt;= s.length &lt;= 1000 s 仅由小写英文字母组成 本题用动规做会方便一点。 先定义状态。 由于求的是一个子序列区间，定义一段区间需要左端点和右端点。用一个上三角矩阵来存储状态。 具体的，dp[i][j]的含义为在[i,j]区间内，能得到的回文子序列最大长度。 再求转移方程。 由图可知，由某一坐标出发，向左或向下，都在坐标所包含的区间范围内，理解了这个的基础上。 我们可以定义，如果s[i] = s[j] ，那么在[i,j]区间内，能获得的最大回文子序列长度应该是去掉两端后能得到的最大长度，加上两端，即 dp[i][j] = dp[i + 1][j - 1] + 2 即使i+1&gt;j-1也不影响结果。 如果s[i] ≠ s[j]，是不是可以直接另[i,j]的状态值，等于[i+1,j-1]的状态值呢，显然不可以。 例如，”bbbba”在[0,4]区间上，’a’≠’b’,但是’b’可以与”bbbba”中的’b‘组合形成回文，如果按照上面的思路，dp[0,4]的值应该是3，而实际是4。 因此此时的状态转移方程应该为 f[i][j] = max(f[i + 1][j], f[i][j - 1]) 下一步定初始化。 初始化即为 dp[i][i] = 1，因为每一个元素自成回文序列。 最后定义返回状态值 即最大区间求得的状态值dp[0][n-1] 完整代码如下： 123456789101112131415161718class Solution &#123;public: int longestPalindromeSubseq(string s) &#123; int n = s.length(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); for (int i = n - 1; i &gt;= 0; i--) &#123; dp[i][i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s[i] == s[j]) &#123; dp[i][j] = dp[i + 1][j - 1] + 2; &#125; else &#123; dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[0][n - 1]; &#125;&#125;; 进阶：这里还可以用状态压缩把二阶dp化简成一阶dp，太麻烦了先不做了。","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://songlinlibit.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://songlinlibit.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"test2","slug":"test2","date":"2021-05-25T07:14:04.000Z","updated":"2021-06-06T06:22:40.447Z","comments":true,"path":"2021/05/25/test2/","link":"","permalink":"https://songlinlibit.github.io/2021/05/25/test2/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"test","slug":"test","date":"2021-05-25T04:31:26.000Z","updated":"2021-05-25T04:31:26.865Z","comments":true,"path":"2021/05/25/test/","link":"","permalink":"https://songlinlibit.github.io/2021/05/25/test/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://songlinlibit.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://songlinlibit.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]}