{"meta":{"title":"libit的博客","subtitle":"祝你每天开心","description":"每天进步一丢丢","author":"libit","url":"https://songlinlibit.github.io","root":"/"},"pages":[{"title":"个人简历","date":"1996-10-18T16:00:00.000Z","updated":"2021-06-07T03:01:34.851Z","comments":true,"path":"CV/index.html","permalink":"https://songlinlibit.github.io/CV/index.html","excerpt":"","text":"这是一个简历展示页面包括但不限于个人的专业技能展示，如果仅需了解本人专业知识，为节省您的时间，请移步这里"}],"posts":[{"title":"08/12","slug":"08-12","date":"2021-08-12T08:52:20.000Z","updated":"2021-08-12T09:04:34.809Z","comments":true,"path":"2021/08/12/08-12/","link":"","permalink":"https://songlinlibit.github.io/2021/08/12/08-12/","excerpt":"516. 最长回文子序列给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 示例 2： 123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 1 &lt;= s.length &lt;= 1000 s 仅由小写英文字母组成","text":"516. 最长回文子序列给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 示例 2： 123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 1 &lt;= s.length &lt;= 1000 s 仅由小写英文字母组成 本题用动规做会方便一点。 先定义状态。 由于求的是一个子序列区间，定义一段区间需要左端点和右端点。用一个上三角矩阵来存储状态。 具体的，dp[i][j]的含义为在[i,j]区间内，能得到的回文子序列最大长度。 再求转移方程。 由图可知，由某一坐标出发，向左或向下，都在坐标所包含的区间范围内，理解了这个的基础上。 我们可以定义，如果s[i] = s[j] ，那么在[i,j]区间内，能获得的最大回文子序列长度应该是去掉两端后能得到的最大长度，加上两端，即 dp[i][j] = dp[i + 1][j - 1] + 2 即使i+1&gt;j-1也不影响结果。 如果s[i] ≠ s[j]，是不是可以直接另[i,j]的状态值，等于[i+1,j-1]的状态值呢，显然不可以。 例如，”bbbba”在[0,4]区间上，’a’≠’b’,但是’b’可以与”bbbba”中的’b‘组合形成回文，如果按照上面的思路，dp[0,4]的值应该是3，而实际是4。 因此此时的状态转移方程应该为 f[i][j] = max(f[i + 1][j], f[i][j - 1]) 下一步定初始化。 初始化即为 dp[i][i] = 1，因为每一个元素自成回文序列。 最后定义返回状态值 即最大区间求得的状态值dp[0][n-1] 完整代码如下： 123456789101112131415161718class Solution &#123;public: int longestPalindromeSubseq(string s) &#123; int n = s.length(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); for (int i = n - 1; i &gt;= 0; i--) &#123; dp[i][i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s[i] == s[j]) &#123; dp[i][j] = dp[i + 1][j - 1] + 2; &#125; else &#123; dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[0][n - 1]; &#125;&#125;; 进阶：这里还可以用状态压缩把二阶dp化简成一阶dp，太麻烦了先不做了。","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划 - 状态压缩","slug":"动态规划-状态压缩","permalink":"https://songlinlibit.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"test2","slug":"test2","date":"2021-05-25T07:14:04.000Z","updated":"2021-06-06T06:22:40.447Z","comments":true,"path":"2021/05/25/test2/","link":"","permalink":"https://songlinlibit.github.io/2021/05/25/test2/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"test","slug":"test","date":"2021-05-25T04:31:26.000Z","updated":"2021-05-25T04:31:26.865Z","comments":true,"path":"2021/05/25/test/","link":"","permalink":"https://songlinlibit.github.io/2021/05/25/test/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划 - 状态压缩","slug":"动态规划-状态压缩","permalink":"https://songlinlibit.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]}