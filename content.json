{"meta":{"title":"libit的博客","subtitle":"祝你每天开心","description":"每天进步一丢丢","author":"libit","url":"https://songlinlibit.github.io","root":"/"},"pages":[{"title":"个人简历","date":"1996-10-18T16:00:00.000Z","updated":"2021-06-07T03:01:34.851Z","comments":true,"path":"CV/index.html","permalink":"https://songlinlibit.github.io/CV/index.html","excerpt":"","text":"这是一个简历展示页面包括但不限于个人的专业技能展示，如果仅需了解本人专业知识，为节省您的时间，请移步这里"}],"posts":[{"title":"08/15","slug":"08-15","date":"2021-08-15T11:24:19.000Z","updated":"2021-08-15T11:25:56.199Z","comments":true,"path":"2021/08/15/08-15/","link":"","permalink":"https://songlinlibit.github.io/2021/08/15/08-15/","excerpt":"","text":"5844. 数组元素的最小非零乘积 给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次： 从 nums 中选择两个元素 x 和 y 。选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。 请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 10$^9$ + 7 取余 后返回。 注意：答案应为取余 之前 的最小值。 这个题前半段不难想，举个例子 如果p是4的话，其所有的二进制数的结果应该是 0000 11110001 11100010 11010011 11000100 10110101 10100110 10010111 1000 可以看到1的数量是一定的，0的数量也是一定的，而且是相同的。 这8行的组合，已经搭配出了所有的可能给出的互补结果。 那么乘积最小的，肯定是越靠近区间两边的，也就是1和14，通过优先次的互换可以实现所有的元素都变成1和14 这里因为题目要求从0开始，因此15单独拉出来算。 总结公式，对于给定的p $ans=(2^p-1)*2^p-2^{2^{p-1}-1}$ 对应上面的例子，p=4的时候，有 $ans =15*14^7$ 以上是第一步，数学推导的过程。 如果按照这种思路写出代码，会发现超时，因为当p=60的时候，计算乘方是一件非常浪费时间的事情。 这里用快速乘方会解决很多问题。 在网上找了好几个介绍快速乘方的资料，但是都不是特别好，因为个人博客终究还是不太系统，找到了一个不错的wiki： 引用自：https://oi-wiki.org/math/quick-pow/ 快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $\\Theta(\\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $\\Theta(n)$ 的时间。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。 算法描述计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起：$a^{n} = \\underbrace{a \\times a \\cdots \\times a}_{n\\text{ 个 a}}$。然而当 $a,n$ 太大的时侯，这种方法就不太适用了。不过我们知道：$a^{b+c} = a^b \\cdot a^c,,,a^{2b} = a^b \\cdot a^b = (a^b)^2$。二进制取幂的想法是，我们将取幂的任务按照指数的 二进制表示 来分割成更小的任务。 首先我们将 $n$ 表示为 2 进制，举一个例子： $$3^{13} = 3^{(1101)_2} = 3^8 \\cdot 3^4 \\cdot 3^1$$ 因为 $n$ 有 $\\lfloor \\log_2 n \\rfloor + 1$ 个二进制位，因此当我们知道了 $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log_2 n \\rfloor}}$ 后，我们只用计算 $\\Theta(\\log n)$ 次乘法就可以计算出 $a^n$。 于是我们只需要知道一个快速的方法来计算上述 3 的 $2^k$ 次幂的序列。这个问题很简单，因为序列中（除第一个）任意一个元素就是其前一个元素的平方。举一个例子： $$\\begin{align}3^1 &amp;= 3 \\3^2 &amp;= \\left(3^1\\right)^2 = 3^2 = 9 \\3^4 &amp;= \\left(3^2\\right)^2 = 9^2 = 81 \\3^8 &amp;= \\left(3^4\\right)^2 = 81^2 = 6561\\end{align}$$ 因此为了计算 $3^{13}$，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了： $$3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323$$ 将上述过程说得形式化一些，如果把 $n$ 写作二进制为 $(n_tn_{t-1}\\cdots n_1n_0)_2$，那么有： $$n = n_t2^t + n_{t-1}2^{t-1} + n_{t-2}2^{t-2} + \\cdots + n_12^1 + n_02^0$$ 其中 $n_i\\in{0,1}$。那么就有 $$\\begin{aligned}a^n &amp; = (a^{n_t 2^t + \\cdots + n_0 2^0})\\\\&amp; = a^{n_0 2^0} \\times a^{n_1 2^1}\\times \\cdots \\times a^{n_t2^t}\\end{aligned}$$ 根据上式我们发现，原问题被我们转化成了形式相同的子问题的乘积，并且我们可以在常数时间内从 $2^i$ 项推出 $2^{i+1}$ 项。 这个算法的复杂度是 $\\Theta(\\log n)$ 的，我们计算了 $\\Theta(\\log n)$ 个 $2^k$ 次幂的数，然后花费 $\\Theta(\\log n)$ 的时间选择二进制为 1 对应的幂来相乘。 代码实现首先我们可以直接按照上述递归方法实现： 123456789long long binpow(long long a, long long b) &#123; if (b == 0) return 1; long long res = binpow(a, b / 2); if (b % 2) return res * res * a; else return res * res;&#125; 第二种实现方法是非递归式的。它在循环的过程中将二进制位为 1 时对应的幂累乘到答案中。尽管两者的理论复杂度是相同的，但第二种在实践过程中的速度是比第一种更快的，因为递归会花费一定的开销。 12345678910long long binpow(long long a, long long b) &#123; long long res = 1; while (b &gt; 0) &#123; if (b &amp; 1) res = res * a; a = a * a; b &gt;&gt;= 1; &#125; return res;&#125; 完整代码如下： 1234567891011121314151617181920#define MOD 1000000007#define LL long long class Solution &#123;public: LL quick_pow(LL a, LL n)&#123; LL ans = 1; a %= MOD; while(n&gt;0)&#123; if(n&amp;1) ans = ans*a%MOD; a = a*a%MOD; n &gt;&gt;= 1; &#125; return ans; &#125; int minNonZeroProduct(int p) &#123; LL a = ((LL)1&lt;&lt;p)%MOD; LL n = (((LL)1&lt;&lt;(p-1))-1) ; return (int)((a-1)*quick_pow(a-2,n)%MOD); &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"https://songlinlibit.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"数学归纳","slug":"数学归纳","permalink":"https://songlinlibit.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3/"}]},{"title":"08/13","slug":"08-13","date":"2021-08-13T09:40:34.000Z","updated":"2021-08-13T09:44:27.367Z","comments":true,"path":"2021/08/13/08-13/","link":"","permalink":"https://songlinlibit.github.io/2021/08/13/08-13/","excerpt":"","text":"647. 回文子串给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 输入：“abc”输出：3解释：三个回文子串: “a”, “b”, “c” 示例 2： 输入：“aaa”输出：6解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa” 提示： 输入的字符串长度不会超过 1000 。 这个题跟昨天做的有一点点像，都是求回文子序列。 所以是可以用昨天动规的思路来求解的。 但是我用了中心扩展法，因为动规的空间复杂度会高一点。 中心扩展法时间复杂度是 $O(N^2)$, 空间复杂度是 $O(1)$ 动态规划时间复杂度是 $O(N^2)$，空间复杂度是 $O(N^2)$ 具体原理就是以每个元素为中心，挨个向两边扩散，比如现在以”bab”中的a为中心扩散，由于’b’ = ‘b’ ，标记为合法的回文子串，继续扩散到达边界结束。 思路就这样，非常简单。想不到有啥需要补充了。 完整代码： 12345678910111213141516171819202122232425class Solution &#123;public: int count(int left, int right, string s)&#123; int len = s.size(); int re = 0; while(left&gt;=0 &amp;&amp; right&lt;len &amp;&amp; s[left] == s[right])&#123; left--; right++; re++; &#125; return re; &#125; int countSubstrings(string s) &#123; int ans = 0; int len = s.size(); for(int i = 0; i&lt;len; i++)&#123; ans++; int left = i -1, right = i+1; ans += count(left,right,s); left = i-1, right = i; ans += count(left,right,s); &#125; return ans; &#125;&#125;; 补充： 后来发现别人更好的方法，因为中心点只能是1个或者2个。 为什么不能是3个，因为3个就是1个往两边扩展了一下呗。 所以代码可以优化一下，主要优化left和right的取值。 1int l=i/2,r=i/2+i%2; 优化后代码如下： 12345678910111213141516171819class Solution &#123;public: int countSubstrings(string s) &#123; int n=s.size(),ans=0; for(int i=0;i&lt;2*n-1;++i)&#123; int l=i/2,r=i/2+i%2; while(l&gt;=0&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r])&#123; l--; r++; ans++; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"08/12","slug":"08-12","date":"2021-08-12T08:52:20.000Z","updated":"2021-08-12T09:31:28.627Z","comments":true,"path":"2021/08/12/08-12/","link":"","permalink":"https://songlinlibit.github.io/2021/08/12/08-12/","excerpt":"","text":"516. 最长回文子序列给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 示例 2： 123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 1 &lt;= s.length &lt;= 1000 s 仅由小写英文字母组成 本题用动规做会方便一点。 先定义状态。 由于求的是一个子序列区间，定义一段区间需要左端点和右端点。用一个上三角矩阵来存储状态。 具体的，dp[i][j]的含义为在[i,j]区间内，能得到的回文子序列最大长度。 再求转移方程。 由图可知，由某一坐标出发，向左或向下，都在坐标所包含的区间范围内，理解了这个的基础上。 我们可以定义，如果s[i] = s[j] ，那么在[i,j]区间内，能获得的最大回文子序列长度应该是去掉两端后能得到的最大长度，加上两端，即 dp[i][j] = dp[i + 1][j - 1] + 2 即使i+1&gt;j-1也不影响结果。 如果s[i] ≠ s[j]，是不是可以直接另[i,j]的状态值，等于[i+1,j-1]的状态值呢，显然不可以。 例如，”bbbba”在[0,4]区间上，’a’≠’b’,但是’b’可以与”bbbba”中的’b‘组合形成回文，如果按照上面的思路，dp[0,4]的值应该是3，而实际是4。 因此此时的状态转移方程应该为 f[i][j] = max(f[i + 1][j], f[i][j - 1]) 下一步定初始化。 初始化即为 dp[i][i] = 1，因为每一个元素自成回文序列。 最后定义返回状态值 即最大区间求得的状态值dp[0][n-1] 完整代码如下： 123456789101112131415161718class Solution &#123;public: int longestPalindromeSubseq(string s) &#123; int n = s.length(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); for (int i = n - 1; i &gt;= 0; i--) &#123; dp[i][i] = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (s[i] == s[j]) &#123; dp[i][j] = dp[i + 1][j - 1] + 2; &#125; else &#123; dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; &#125; return dp[0][n - 1]; &#125;&#125;; 进阶：这里还可以用状态压缩把二阶dp化简成一阶dp，太麻烦了先不做了。","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://songlinlibit.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://songlinlibit.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"test2","slug":"test2","date":"2021-05-25T07:14:04.000Z","updated":"2021-06-06T06:22:40.447Z","comments":true,"path":"2021/05/25/test2/","link":"","permalink":"https://songlinlibit.github.io/2021/05/25/test2/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"test","slug":"test","date":"2021-05-25T04:31:26.000Z","updated":"2021-05-25T04:31:26.865Z","comments":true,"path":"2021/05/25/test/","link":"","permalink":"https://songlinlibit.github.io/2021/05/25/test/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://songlinlibit.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"https://songlinlibit.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"数学归纳","slug":"数学归纳","permalink":"https://songlinlibit.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://songlinlibit.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://songlinlibit.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]}